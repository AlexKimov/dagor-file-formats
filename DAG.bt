//------------------------------------------------
//--- 010 Editor v8.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

local uint n, i, k, n0;
local float Size, Sz, cnt;

uint getType()
{
  local uint type;
  FSkip(4);
  type = ReadInt(FTell());
  FSkip(-4);
  return type;
}

struct {
  UCHAR Magic[4]; // signature
  UINT DataSize;
  UCHAR DAG[4];
} HEADER <name="File Header">;

typedef struct {
  UINT DataSize;
  UINT Type;
  BYTE MNLength;
  UCHAR MaterialName[MNLength];
  struct {
    INT Unknown;
    INT Unknown;
    INT Unknown;
    FLOAT Unknown;
    INT Unknown;
    INT16 TextureIndex;
    INT16 Unknown;
    INT Unknown;
    INT Unknown;
    INT Unknown;
    FLOAT Unknown;
    FLOAT Unknown;
    INT Unknown;
    INT Unknown;
    INT Unknown;
    INT Unknown;
    INT Unknown;
    INT Unknown;
    BYTE Length;
    UCHAR LightMapName[Length];
  } PROPERTIES;
  UBYTE U[DataSize - (MNLength + PROPERTIES.Length + 74)];
} MATERIAL <name=GetMatName>;


while (!FEof())
{ 
  FSkip(4);
  n = ReadInt(FTell());
  if (n == 0) break;
  FSkip(-4);

  if (n == 4) 
    struct {
      UINT DataSize;
      UINT Type;
      UINT16 Count;
      typedef struct {
          BYTE Length;
          UCHAR FileName[Length];
      } NAME <optimize=false, name=GetTexName>;
      typedef struct (uint arraysize) {
        NAME Array[arraysize];
      } NAME_ARRAY <optimize=false>;
      NAME_ARRAY FileNames(Count) <name="State Names">;     

      UINT DataSize;
      UINT Type;
      struct {  
        UINT16 Index;
        UINT Pos;
      } A[Count];
    } STATE_LIST <name="States">;

  if (n == 3) 
    struct {
      UINT DataSize;
      UINT Type;
      UINT16 TextureCount;
      typedef struct {
          BYTE Length;
          UCHAR FileName[Length];
      } FILE_NAME <optimize=false, name=GetTexName>;
      typedef struct (uint arraysize) {
        FILE_NAME Array[arraysize];
      } FILE_NAME_ARRAY <optimize=false>;
      FILE_NAME_ARRAY FileNames(TextureCount) <name="Texture List">;     
    } TEXTURE <name="Textures">;

  if (n == 2) 
    MATERIAL Material;

  if (n == 1)
    struct {
        while (!FEof()) {  
            INT DataSize;
            UINT Type;
        
            switch (Type) {
              case 7:
                break;
        
              case 5:
                  struct {
                    BYTE Data[DataSize - 4];
                  } DATA_5;
                break;
        
              case 4:
                  struct {
                    UINT Size;
        
                    if (Size == 38) {
                      UINT16 VertexCount;
                      struct {
                        FLOAT X;
                        FLOAT X;
                        FLOAT Z;
                      } VERTEX[VertexCount];             
                    } else {
                      UINT Index; 
        
                      UINT16 VertexCount;
                      struct {
                        FLOAT X;
                        FLOAT X;
                        FLOAT Z;
                      } VERTEX[VertexCount];
        
                      UINT16 CountA;
                      struct {
                        UINT16 I1;
                        UINT16 I3;
                        UINT16 I2;
                        UINT16 I1;
                        UINT16 I3;
                        UINT16 I2;
                      } INDEXES[CountA]; 
        
                      BYTE A;
                      if (A) {
                        UINT16 Count;
                        UINT16 Unknown;

                        if (A == 9) {
                          struct {
                            FLOAT X;
                            FLOAT X;
                            FLOAT X;
                          } UNO[Count];                          
                        } else {
                        struct {
                          FLOAT X;
                          FLOAT X;
                        } UV[Count];
                       }
        
                       struct {
                          UINT16 I1;
                          UINT16 I2;
                          UINT16 I2;
                        } N[CountA];
                      };
        
                      UINT Count;
                      BYTE U[Count];
                    };
                  } DATA_4;        
                break;
        
              case 3:
                  struct {
                    if (DataSize > 8) {
                      UCHAR ObjectName[DataSize - 4]; 
                    };            
                  } DATA_3;
                break;
        
              case 2:
                  struct {
                    INT16 Index;
                    INT16 Count;
                    INT16 Index;
                    INT16 Index;
                    if (DataSize > 12) {
                      UCHAR ObjectName[DataSize - 12]; 
                    };
                  } DATA_2;
                break;
        
              case 1:
                if (DataSize == 52)
                {
                  struct {
                    FLOAT X;
                    FLOAT Y;
                    FLOAT Z;
             
                    FLOAT X;
                    FLOAT Y;
                    FLOAT Z;
            
                    FLOAT X;
                    FLOAT Y;
                    FLOAT Z;
            
                    FLOAT PosX;
                    FLOAT PosY;
                    FLOAT PosZ; 
                  } MATRIX;   
                }
                break;
            };
        };   
    } GEOMETRY;  
}

//string GetObjName(OBJECT &obj)
//{
//  return "Object: " + obj.ObjectName;
//}

string GetTexName(FILE_NAME &fn)
{
  return "Texture: " + fn.FileName;
}

string GetMatName(MATERIAL &mt)
{
  if (exists(mt.MaterialName))
    return "Material: " + mt.MaterialName;
  else
    return "Material";    
}